{"name":"Redscript","tagline":"A Ruby Flavored JavaScript Experiment","body":"# RedScript Spec Sheet\r\n\r\nIf you have suggestions on different syntax, please create\r\nan issue: [here](https://github.com/AdamBrodzinski/RedScript/issues).\r\n\r\n<br>\r\n\r\n#### Variables & automatic semi-colon insertion  \r\n*Status*: **Partially implemented, known bug**\r\n\r\nVariables are automatically declared. Using the var keyword is optional and allowed.  \r\nConstants are pre-processed at compile time. This allows some memory savings in certain cases where itcan be utilized.\r\nSemi-colons are automatically inserted as needed (currently not implemented).\r\n\r\n\r\n*Currently RedScript does not take function scope into account. Any\r\nvariables that are declared inside of a function multiple times can\r\nlead to unintended global leaks. To disable auto declaration pass\r\ndeclare variables with the var keyword.* \r\n\r\n```ruby\r\nfoo = 12                 var foo = 12;\r\nfoo = 20                 foo = 20;\r\n\r\n# Constants are preprocessed\r\nAMOUNT = 233            \r\nputs AMOUNT             console.log(233)\r\n\r\n# !! Lexical scoping bug in current version !!\r\nfunc foo                var foo = function() {\r\n  baz = 20                var baz = 20;       \r\nend                     };                    \r\n\r\nfunc bar                var bar = function() {\r\n  baz = 30                baz = 30;       \r\nend                     };                     \r\n```\r\n<br>\r\n\r\n#### Convenience method aliases for puts & printf\r\n\r\n*Status:* **Working**  \r\n`puts` and `printf` are aliases to `console.log` and `process.stdout.write`. `printf` is only available with node enviroments. These are the only methods that have optional parens at this time. If parens are omitted a closing paren will be appended to the end of the line. Parenless multi lines are not possible.\r\n\r\n```ruby\r\nputs \"Hello there\"                      console.log(\"Hello there\");\r\nputs(\"Hai!\")                            console.log(\"Hai\")\r\nprintf \"Hola\"                           process.stdout.write(\"Hola\")\r\nprintf(\"Hola\")                          process.stdout.write(\"Hola\")\r\n```\r\n<br>\r\n\r\n#### Optional Parenthesis\r\n\r\n*Status:* **Implemented with RedScript constructs only**\r\n\r\nCurrently I cannot implement this until I can create a proper lexer. Pull requests welcome ;-) For the time being you have to include parens. A temporary kludgey alias for `end)` is `end-`. This is slightly easier to look at for the short run, but expect this to be dropped in the future.\r\n\r\n```ruby\r\nalert 'Hello World!'\r\n\r\ngetUser '/users/1', do\r\n  alert user\r\nend\r\n\r\n# Currently you still have to use parens for anything that's not a RedScript construct.\r\ngetUser( '/users/1', do\r\n  alert(user)\r\nend)\r\n\r\n# A kludgey alias for `end)` is `end-`\r\ngetUser( '/users/1', do\r\n  alert(user)\r\nend-\r\n```\r\n<br>\r\n\r\n\r\n#### Ruby flavored functions\r\n\r\n`Func [name]` declares the function as an expression and sets `[name]` to a variable. Parens are optional if no arguments are being passed. If arguments are passed braces must be used. Anonymous functions are declared as `func`, parens are also optional. This type of anonymous function should only be used when using `do |x|` would be awkward, such as in an [async](https://github.com/caolan/async)'s array of parallel functions.\r\n\r\n*Status:* **Working**\r\n\r\n```ruby\r\nfunc say(msg)                            var say = function(msg) {\r\n  puts \"Message: #{msg}\"                   console.log(\"Message: \" + msg);\r\nend                                      };\r\n\r\n# Optional function parens\r\nfunc sayHello\r\n  puts \"Hello\"\r\nend\r\n\r\n# anonymous function\r\nfunc                                    function() {\r\n  # do stuff                              // do stuff\r\nend                                     }\r\n\r\nfunc(a,b)                               function(a,b) {\r\n  # do stuff                              // do stuff\r\nend                                     }\r\n```\r\n<br>\r\n\r\n#### Comments\r\n\r\n*Status*: *Working*\r\n\r\nLine comments are made with a `#`. RedScript currently does not have multi-line comments but `/*...*/` can be used if needed.\r\n\r\n```coffeescript\r\n# I'm a comment                          // I'm a comment\r\n$('#someID').html(foo)                   $('#someID').html(foo) # No worries here\r\n```\r\n<br>\r\n\r\n#### Alias @ with this\r\n\r\n*Status:* Working\r\n\r\n```ruby\r\nfunction FooClass(name, age) {           function FooClass(name, age){\r\n  @name = name                             this.name = name;\r\n  @age = age                               this.age = age;\r\n}                                        }\r\n```\r\n<br>\r\n\r\n\r\n#### Loops\r\n\r\n*Status:* **Working**\r\n\r\n*Note*, for loops only support `0..3`, `0...3` or variables e.g. `begin...ending`. Using two dots will loop up until that number, and using 3 dots will loop up to and including the end number.  \r\nUsing `for in [2,4,6]` or `for in myArray` will not work at this time. See next section for more info on arrays.  \r\nTo prevent confusion until loops have a `//until` comment next to the compiled output.\r\n\r\n```ruby\r\nwhile foo < 200                        while (foo < 200) {\r\n  puts \"I'm looping forever\"              console.log(\"I'm looping forever\");\r\nend                                     }\r\n\r\n\r\n# loops until a condition is true\r\nuntil i == 5                            while (!(i == 5)) { // loop until  \r\n   puts i                                  console.log(i);                \r\n   i += 1                                  i += 1;                        \r\nend                                     }                                 \r\n                                        \r\n                                        \r\n# prints 5x, 0,1,2,3,4                  \r\nfor i in 0..5                           for (var i=0; i < 5; i++) {    \r\n  puts i                                  console.log(i);           \r\nend                                     }                             \r\n                                        \r\n                                        \r\n# prints 6x, 0,1,2,3,4,5                \r\nfor i in 0...5                          for (var i=0; i <= 5; i++) {\r\n  puts i                                  console.log(i)       \r\nend                                     }                          \r\n```\r\n<br>\r\n\r\n\r\n#### Iterating over arrays and objects\r\n\r\n*Status:* **Working**\r\n\r\n```\r\n# Iterate over arrays\r\nbasket = ['lemon', 'pear', 'apple']     var basket = ['lemon', 'pear', 'apple'];\r\n\r\nfor fruit inArr basket                  for (var _i=0, _len=basket.length; _i < _len; _i++) { var fruit = basket[_i];    \r\n  puts fruit                              console.log(fruit);                                                            \r\nend                                     }                                                                                \r\n\r\n\r\nfor key in obj                          for (var key in obj) {\r\n   alert(key)                             alert(key);\r\nend                                     }\r\n\r\n\r\nfor key,val in obj                      for (var key in obj) { var val = obj[key];\r\n  puts 'My key is: #{key}'                console.log('My key is: ' + key);\r\n  puts 'My value is: #{val}'              console.log('My value is: ' + val);\r\nend                                     }\r\n```\r\n<br>\r\n\r\n#### If/else/else if\r\n\r\n*Status:* **Partially implemented**\r\n\r\nIf statements currently are multi-line. If you would like to use a one liner, you can still use vanilla js `if (err) throw err;`.\r\n\r\n```ruby\r\nif foo == 10                            if (foo === 10) {\r\n  bar(\"do stuff\")                         bar(\"do stuff\");\r\nelse if foo == 20                       } else if (foo === 20) {\r\n  bar(\"do stuff\")                         bar(\"do stuff\");\r\nelse                                    } else {\r\n  bar(\"do stuff\")                         bar(\"do stuff\");\r\nend                                     }\r\n\r\nthrow err if err                        if (err) { throw err; }\r\n```\r\n<br>\r\n\r\n#### Methods & Object Literal\r\n\r\n*Status:* **Working**\r\n\r\nAn optional way to declare an object literal. The idea is to make it read a bit nicer.  \r\nMethods are declared using the def keyword and parens are optional *if* they're not used.  \r\nAttaching a method to an object's prototype be defined using `def objName >>> mthdName`.\r\n\r\n```ruby\r\nobject auto                                   var auto = {\r\n  wheels: 4,                                    wheels: 4,\r\n  engine: true,                                 engine: true,\r\n\r\n  def honk                                      honk: function() {\r\n    puts \"hoooonk\"                                console.log(\"hooooonk\");\r\n  end,                                          },\r\n\r\n  def sayHi(msg)                                sayHi: function(msg) {\r\n    puts msg                                      console.log(msg);\r\n  end                                           }\r\nend                                           }\r\n\r\n# Define outside of object literal\r\ndef auto.add(x, y)                            auto.add = function(x,y) {\r\n  return x + @wheels                            return x + this.wheels;\r\nend                                           };\r\n\r\n# Define method attached to prototype\r\ndef Car >>> sub(x,y)                          Car.prototype.sub = function(x, y) {\r\n  return x - y                                  return x - y;\r\nend                                           };\r\n```\r\n<br>\r\n\r\n#### Block-like Syntax for Anonymous Functions\r\n\r\n*Status:* **Working**\r\n\r\nBlock like syntax is a shorter way to write an anonymous function. The preceding comma is optional. However, including it may be easier to understand if it's included. Once we have optional parens working this will look *much* nicer! \r\n```ruby\r\n\r\napp.get('/users/:user', do |req|        app.get('/users/:user', function(req) {\r\n  puts req.params.name                    console.log(req.params.name);\r\nend)                                    });\r\n\r\n# no params\r\n$myBtn.click( do                        $myBtn.click( function() {\r\n  alert(\"hi\")                             alert(\"hi\");\r\nend)                                    });\r\n```\r\n<br>\r\n\r\n#### RequireJS Module Sugar \r\n\r\n*Status:* **Not Implemented**  \r\n\r\nUsing `define module` wraps the current file in a new anonymous RequireJS module. Exports can either be exported in a export object literal or by using `export foo` to export the foo variable only. Any dependencies can be declared by using `require 'foo' as foo` which sets up foo's returned value in a variable called `foo`.\r\n\r\n```ruby\r\n\r\ndefine module                                                   define([ 'jquery',\r\nrequire 'jquery' as $                                                    './views/widget'],\r\nrequire './views/widget' as Widget                                function($, Widget) {        \r\n\r\noptions = {                                                        var options = {\r\n  moonRoof: true,                                                    moonRoof: true,   \r\n  seats: 5                                                           seats: 5      \r\n}                                                                  }          \r\n\r\ngetCost = 16899                                                    var getCost = 16899;\r\nwheels = 4                                                         var wheels = 4;\r\n \r\n# export literal compiles to an object that gets returned\r\nexport                                                              return {   \r\n  getCost                                                               getCost : getCost,\r\n  hasMoonRoof from options.moonRoof                                     hasMoonRoof : options.moonRoof,   \r\n  getWheels from wheels                                                 getWheels : wheels     \r\nend                                                                 }           \r\n                                                                }); \r\n# --------------------------------------  new file  -------------------------------------------\r\ndefine module                                                  define(function() {\r\n\r\nfunc foo(x)                                                      var foo = function(x) {\r\n  puts x                                                           console.log(x);\r\nend                                                              }\r\n\r\nexport foo                                                       return foo; });\r\n```\r\n<br>\r\n\r\n#### Ruby / Coffee style case switch statement\r\n\r\n*Status:* **Working**\r\n\r\nSwitch statements still need `break` inserted to prevent falling through. The exception is one liners, then it's appened to the line.\r\n\r\n```ruby\r\nswitch fruit                                             switch (fruit) {\r\nwhen \"apple\"                                               case \"apple\":\r\n  puts \"it's an appppple\"                                    console.log(\"it's an appppple\");\r\n  break                                                      break;\r\nwhen \"bannana\" then puts(\"bannana\")                        case \"bannana\": console.log(\"bannana\"); break;\r\nwhen \"orange\"                                              case \"orange\":\r\n  puts \"it's an orange\"                                      console.log(\"it's an orange\");\r\n  break                                                      break;\r\ndefault                                                    default:\r\n  puts \"uh oh, bummer\"                                       console.log(\"uh oh, bummer\");\r\nend                                                      }\r\n```\r\n<br>\r\n\r\n#### Private Blocks\r\n\r\n*Status:* **Working**\r\n\r\nPrivate blocks keep variables scoped inside the block using function scope. There is a slight performance hit due to the IIFE. Again, due to the lack of proper lexing/parsing I can't yet use an `end` block. A workaround is `endPriv`, this calls the IIFE. Also due to the variable declaration bug mention above, variables like the example below will currently need var manually inserted to keep `foo` from leaking out and changing global `foo` to `10`. The beginning of the IIFE is nerfed with a semi-colon to prevent any potential errors (especially with the current state of RedScript not having automatic semi-colon insertion). \r\n\r\n```ruby                                                   \r\nfoo = 200                                                 var foo = 200; \r\n\r\nprivate                                                  (function(){\r\n  var foo = 10                                              var foo = 10;\r\nendPriv                                                   })();\r\n\r\nalert(foo) #alerts 200                                    alert(foo);\r\n```\r\n<br>\r\n\r\n#### Classical Inheritance\r\n\r\n*Status*: **Working**\r\n\r\nRedScript classes are currently using John Resig's simple inheritance. In the future a solution closer to coffeescript would be ideal, allowing one to inherit from any constructor and still have the correct syntax. The current implementation will not inherit unless the base class is created with RedScript. However, backbone and ember both use the `.extend` method which is convenient since using `class Foo < Backbone.Model.extend(` will call their own extend implementation. Backbone does not have a `this._super` method so if you want to call super you would need to use a backbone plugin for that. Ember uses the same `this._super` syntax as RedScript so calling super will call Ember's implementation.\r\n\r\nIf you're only using their inheritance implementation you can disable the insertion of RedScript's inheritance by passing the `--no-class` flag.\r\n\r\n```ruby\r\nclass Animal                                          var Animal = Class.extend({           \r\n  def init(name)                                        init: function(name) {              \r\n    @name = name                                          this.name = name;                 \r\n  end,                                                  },                                  \r\n                                                                                            \r\n  def sayHi                                             sayHi: function() {                 \r\n    puts \"Hello\"                                          console.log(\"Hello\");             \r\n  end                                                   }                                   \r\nend                                                   });                                   \r\n                                                                                            \r\nclass Duck < Animal                                   var Duck = Animal.extend({            \r\n  def init                                              init: function(name) {              \r\n    alert(\"#{@name} is alive!\")                           alert(this.name + \" is alive!\")   \r\n  end,                                                  },                                  \r\n                                                                                            \r\n  def sayHi                                             sayHi: function() {                 \r\n    super                                                 this._super();                    \r\n    puts \"Quack\"                                          console.log(\"Quack\");             \r\n  end                                                   }                                   \r\nend                                                   });                                   \r\n\r\nduck = new Duck('Darick')                             var duck = new Duck('Darick');\r\nduck.sayHi()                                          duck.sayHi();\r\n```\r\n<br>\r\n\r\n#### Prototypal Inheritance\r\n\r\n*Status*: **Partially Implemented**\r\n\r\nThis is an experiment to try and bring out JavaScripts true prototypal nature. The goal is to be able to *easily* inherit without using constructors or faux classes. Vanilla JS makes it very difficult to inherit from another object, unlike [self](http://en.wikipedia.org/wiki/Self_programming_language#Inheritance.2FDelegation), JavaScript's inheritance inspiration. One of the drawbacks to property delegation is keeping state in an object. Using `object myDuck clones duck` will copy all of the properties from duck into myDuck, ensuring it won't grab it's parents property by accident. Currently `clones` is not implemeneted yet.\r\n\r\n```ruby\r\nobject animal\r\n  name: null,\r\n  \r\n  def sayHi\r\n    puts \"Hello\"\r\n  end\r\nend\r\n\r\nobject duck\r\n  parent*: animal,\r\n  name: null,\r\n\r\n  def sayHi\r\n    puts \"Quack\"\r\n  end\r\nend\r\n\r\n# this duck's attr's are cloned instead of deligated\r\n# with `parent*`, usefull for statefull objects\r\n#\r\nobject myDuck clones duck\r\n  name: 'Darick'\r\nend\r\n```\r\n","google":"UA-38075559-3","note":"Don't delete this file! It's used internally to help with page regeneration."}